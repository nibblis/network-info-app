# Демонстрация знаний по MVVM

Этот документ объясняет архитектурный шаблон MVVM (Model-View-ViewModel) на примере текущего проекта, затрагивая потоки данных, управление состоянием и жизненным циклом.

### 1. Слои в MVVM

MVVM делит приложение на три основных слоя, чтобы сделать его тестируемым, масштабируемым и простым для понимания.

#### View (Представление)
-   **Что это:** Ваш UI. В данном проекте — это **Composable-функции** (экраны).
-   **Ответственность:** Только отображение данных и передача действий пользователя (клики) во `ViewModel`.
-   **Правило:** `View` не должна содержать никакой бизнес-логики. Она "глупая".

#### ViewModel (Модель Представления)
-   **Что это:** Посредник между `View` и `Model`.
-   **Ответственность:** Хранит состояние UI (`StateFlow`), обрабатывает действия пользователя и запрашивает данные у `Model` (репозитория).
-   **Особенность:** `ViewModel` **переживает смену конфигурации** (например, поворот экрана). Это позволяет не загружать данные заново.

#### Model (Модель)
-   **Что это:** Слой данных. В вашем проекте это **Репозиторий**, который работает с источниками данных (DAO для Room и ApiService для Retrofit).
-   **Ответственность:** Предоставление и управление данными. Репозиторий решает, откуда брать данные — из кэша (БД) или из сети.

### 2. Поток данных

Данные в MVVM движутся по четко определенному, однонаправленному циклу.

**Схема потока:**

```
   Действие      Запрос данных      Получение данных
(1) |            (2) |                (4) |               (5) |
    V                V                    V                   V
+------+         +-----------+        +------------+      +-----------------+
| View | ------> | ViewModel | ---->  | Repository | <--> | Data Sources    |
| (UI) | <------ | (Логика)  | <----  | (Источник) |      | (Room, Retrofit)|
+------+         +-----------+        +------------+      +-----------------+
    ^                ^
    | (3)            |
    Обновление UI   Обновление состояния
```

1.  **View** сообщает `ViewModel` о действии пользователя (например, `onRefresh()`).
2.  **ViewModel** выполняет бизнес-логику и запрашивает данные у **Репозитория**.
3.  **ViewModel** немедленно обновляет свое состояние (`StateFlow`), например, на `State.Loading`.
4.  **Репозиторий** получает данные из сети или БД и возвращает их во `ViewModel`.
5.  **ViewModel** обновляет свое состояние новыми данными (`State.Success`).
6.  **View**, которая подписана на `StateFlow`, автоматически и реактивно обновляет UI.

### 3. Восстановление состояния и отсутствие утечек

#### Восстановление состояния
При повороте экрана Android уничтожает и заново создает `Activity` и все `View`. Однако `ViewModel` **не уничтожается**. Она сохраняется и привязывается к новой `Activity`. Благодаря этому все данные, которые уже были загружены и хранились во `ViewModel`, не теряются, и их не нужно запрашивать заново.

#### Отсутствие утечек памяти

Долгая операция (например, сетевой запрос) может привести к утечке, если она пытается обновить `View`, которая уже уничтожена. `ViewModel` решает эту проблему с помощью **`viewModelScope`**.

-   `viewModelScope` — это `CoroutineScope`, который привязан к жизненному циклу `ViewModel`.
-   Все корутины, запущенные в `viewModelScope`, **автоматически отменяются**, когда `ViewModel` уничтожается (например, когда пользователь уходит с экрана).

```kotlin
// OrganizationViewModel.kt
fun loadOrganizations() {
    viewModelScope.launch { // Эта корутина отменится сама, если ViewModel будет уничтожена
        // ... делаем сетевой запрос
    }
}
```
Это гарантирует, что у вас не будет утечек, связанных с фоновыми задачами.

### 4. Код-ревью: Пример исправления

**Ситуация:** Разработчик добавил логику форматирования данных прямо в UI-слой.

**❌ Плохо (логика во View):**

```kotlin
// OrganizationsScreen.kt

@Composable
fun OrganizationItem(org: Organization) {
    val countryText = if (org.country.isNullOrBlank()) {
        "Страна не указана"
    } else {
        org.country.uppercase()
    }
    Text(text = countryText)
}
```

**Почему это плохо:**
-   Нарушен принцип Single Responsibility: `View` занимается не только отображением, но и форматированием.
-   Невозможно протестировать эту логику отдельно от UI.
-   Если такое форматирование понадобится на другом экране, придется дублировать код (нарушение DRY).

**✔️ Хорошо (логика в ViewModel):**

1.  Создаем отдельный класс состояния для UI.
    ```kotlin
    // Модель для отображения, а не для данных
    data class OrganizationUiModel(val name: String, val country: String)
    ```

2.  `ViewModel` готовит данные для отображения.
    ```kotlin
    // OrganizationViewModel.kt
    private fun mapToUiModel(org: Organization): OrganizationUiModel {
        val countryText = if (org.country.isNullOrBlank()) {
            "Страна не указана"
        } else {
            org.country.uppercase()
        }
        return OrganizationUiModel(name = org.name, country = countryText)
    }
    ```

3.  `View` просто отображает готовые данные.
    ```kotlin
    // OrganizationsScreen.kt
    @Composable
    fun OrganizationItem(orgUiModel: OrganizationUiModel) {
        Text(text = orgUiModel.country)
    }
    ```
