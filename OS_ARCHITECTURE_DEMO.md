# Демонстрация знаний по архитектуре ОС

Этот документ с помощью схем и примеров объясняет ключевые концепции операционных систем: процессы, потоки, синхронизацию и правила работы с UI.

### 1. Процессы vs. Потоки (Processes vs. Threads)

Представьте ваше Android-приложение как **Процесс**. Это изолированная "песочница", которой ОС выделила собственную память.

**Потоки** — это "работники" внутри этого процесса. У каждого процесса есть как минимум один — **главный (UI) поток**.

**Схема-аналогия:**

```
+---------------------------------------+
| ПРОЦЕСС: Ваше приложение (PID: 1234)  |
|         (Собственная память)          |
|---------------------------------------|
|                                       |
|   +-----------------+   +-----------------+   +-----------------+
|   |    ПОТОК 1      |   |    ПОТОК 2      |   |    ПОТОК 3      |
|   |   (Главный/UI)  |   |   (Сетевой)     |   |   (База данных) |
|   |   - Рисует UI   |   |   - Качает данные|   |   - Пишет в Room|
|   +-----------------+   +-----------------+   +-----------------+
|                                       |
+---------------------------------------+
```

-   **Процесс**: Изолирован, имеет свою память. Если процесс "умирает", все его потоки тоже.
-   **Поток**: Легковесный, работает внутри процесса и делит память с другими потоками этого же процесса. Это делает общение между ними быстрым, но и опасным (см. гонки).

### 2. Примитивы синхронизации

Когда несколько потоков хотят одновременно изменить общие данные, возникают проблемы. Примитивы синхронизации — это инструменты, чтобы навести порядок.

#### Mutex (Мьютекс)

**Mutex (Mutual Exclusion)** — это как ключ от туалета в МакДоналдс. Только один поток, владеющий "ключом", может войти в защищенную секцию кода. Остальные ждут своей очереди.

**Схема-пример:**

```kotlin
val mutex = Mutex()
var counter = 0

// Два потока пытаются одновременно увеличить счетчик

// Поток А
mutex.withLock { // Захватывает мьютекс
    counter++    // Безопасно изменяет данные
} // Освобождает мьютекс

// Поток Б
// ... ждет, пока Поток А освободит мьютекс, потом выполняет то же самое
```
**Итог:** `counter` всегда будет увеличен корректно.

#### Race Condition (Состояние гонки)

**Гонка** — это то, что происходит без мьютекса. Результат зависит от того, какой поток "прибежал" первым.

**Схема-пример гонки:**
1.  `counter` = 0.
2.  Поток А читает `counter` (видит 0).
3.  Поток Б читает `counter` (тоже видит 0).
4.  Поток А записывает `0 + 1 = 1` в `counter`.
5.  Поток Б записывает `0 + 1 = 1` в `counter`.

**Итог:** `counter` равен 1, хотя должен быть 2. Данные повреждены.

#### Deadlock (Взаимная блокировка)

**Дедлок** — это когда два потока вечно ждут друг друга, и работа останавливается. Классический пример — "обедающие философы".

**Схема-пример дедлока:**
1.  Есть два ресурса: `Resource A` и `Resource B`.
2.  Поток 1 захватывает `Resource A` и пытается захватить `Resource B`.
3.  Поток 2 захватывает `Resource B` и пытается захватить `Resource A`.

**Итог:** Поток 1 ждет Поток 2, а Поток 2 ждет Поток 1. Оба потока заблокированы навсегда.

### 3. Правила работы с UI-потоком в Android

**Золотое правило №1: Не блокировать UI-поток.**
Главный (UI) поток отвечает за отрисовку интерфейса (60-120 раз в секунду). Если вы на нем будете выполнять долгую операцию (сеть, чтение из БД, сложный расчет), приложение "зависнет" (появится диалог ANR - Application Not Responding).

**Золотое правило №2: Не обновлять UI из фонового потока.**
Только главный поток имеет право изменять UI-компоненты. Попытка сделать это из другого потока приведет к крешу.

#### Решение: Корутины и Диспетчеры

В современном Android эта проблема элегантно решается корутинами.

**Схема-пример во `ViewModel`:**

```kotlin
viewModelScope.launch { // Запускаем корутину на главном потоке (по умолчанию)
    
    // Показываем индикатор загрузки (можно, т.к. мы в UI-потоке)
    _uiState.value = UiState.Loading
    
    try {
        // Переключаемся на фоновый поток для долгой операции
        val organizations = withContext(Dispatchers.IO) { 
            repository.refreshOrganizations() // Сеть + база данных
        }

        // Автоматически возвращаемся в главный поток
        _uiState.value = UiState.Success(organizations)

    } catch (e: Exception) {
        // Обрабатываем ошибку (тоже в UI-потоке)
        _uiState.value = UiState.Error(e.message)
    }
}
```

-   `Dispatchers.Main`: UI-поток Android.
-   `Dispatchers.IO`: Фоновый поток, оптимизированный для сетевых запросов и работы с файлами/БД.
-   `withContext(...)`: Выполняет код в другом потоке и **дожидается** его завершения, прежде чем продолжить.

Этот подход гарантирует, что UI остается отзывчивым, а все долгие операции выполняются в фоне. Это основа современной многопоточности в Android.
