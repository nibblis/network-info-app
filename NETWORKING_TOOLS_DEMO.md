# Демонстрация работы с Postman и Charles

Этот документ объясняет, как использовать сетевые инструменты для отладки запросов, анализа кэширования и обработки ошибок.

### 1. Postman: Воспроизведение запроса

**Postman** — это инструмент, который позволяет вручную создавать и отправлять HTTP-запросы, минуя код приложения. Это идеально для проверки ответа сервера.

**Как воспроизвести запрос из вашего приложения:**

Допустим, ваше приложение делает GET-запрос для получения списка организаций. В Postman это будет выглядеть так:

1.  **Метод (Method):** Выбираем `GET`.
2.  **URL:** Вставляем URL эндпоинта, например: `https://api.example.com/v1/organizations`.
3.  **Заголовки (Headers):** Переходим на вкладку `Headers` и добавляем все необходимые заголовки, которые отправляет ваше приложение. Самый частый — `Authorization`.
    -   `Key`: `Authorization`
    -   `Value`: `Bearer <ВАШ_ТОКЕН_ДОСТУПА>`
4.  **Тело (Body):** Для GET-запроса тело не нужно.

Нажимаем **Send**. Внизу появится **Ответ (Response)** от сервера — его статус (например, `200 OK`), заголовки и тело (JSON со списком организаций).

**Польза:** Если в Postman запрос работает, а в приложении нет, — проблема точно в коде клиента (например, неправильная сериализация или ошибка в Retrofit-интерфейсе).

### 2. Charles: Перехват трафика (Proxy)

**Charles** — это прокси-сервер, который запускается на вашем компьютере и позволяет "прослушивать" весь сетевой трафик с мобильного устройства.

**Как настроить для Android:**
1.  **Узнать IP компьютера:** В Charles зайти в `Help -> Local IP Address`.
2.  **Настроить прокси на Android:** На телефоне зайти в `Настройки Wi-Fi -> Свойства сети -> Прокси` и ввести IP и порт (обычно `8888`) из Charles.
3.  **Установить SSL-сертификат:** В браузере на телефоне перейти по адресу `chls.pro/ssl` и установить сертификат. Это нужно для расшифровки HTTPS-трафика.
4.  **Разрешить прокси в приложении (для Android 7+):**
    -   В `res/xml/` создать `network_security_config.xml`:
        ```xml
        <network-security-config>
            <debug-overrides>
                <trust-anchors>
                    <certificates src="user" />
                </trust-anchors>
            </debug-overrides>
        </network-security-config>
        ```
    -   В `AndroidManifest.xml` добавить к тегу `<application>`: `android:networkSecurityConfig="@xml/network_security_config"`.

Теперь в окне Charles вы будете видеть все запросы, которые делает ваше приложение.

### 3. Анализ кэш-заголовков

В перехваченном ответе в Charles можно увидеть заголовки, управляющие кэшированием.

-   **`Cache-Control: public, max-age=3600`**
    -   Это инструкция от сервера. `max-age=3600` говорит клиенту (вашему OkHttp), что этот ответ можно считать "свежим" в течение 3600 секунд (1 час) и брать его из кэша, не делая новый сетевой запрос.

-   **`ETag: W/"a1b2-c3d4e5f6"`**
    -   Это "версия" ресурса. Когда `max-age` истечет, клиент сделает запрос, но добавит заголовок `If-None-Match: W/"a1b2-c3d4e5f6"`.
    -   Если данные на сервере не изменились, он ответит статусом **`304 Not Modified`** с пустым телом. Это экономит трафик. Клиент возьмет старые данные из своего кэша.

### 4. Ошибки и Ретраи (Retries)

Анализ статуса ответа помогает понять, что делать дальше.

-   **Клиентские ошибки (4xx):**
    -   `401 Unauthorized`: Неправильный токен. **Повторять (ретраить) запрос бессмысленно.** Нужно получить новый токен.
    -   `404 Not Found`: Неверный URL. **Ретраить бессмысленно.** Нужно чинить код.
    -   `429 Too Many Requests`: Слишком много запросов. **Нужно ретраить**, но с задержкой, которую сервер может указать в заголовке `Retry-After`.

-   **Серверные ошибки (5xx):**
    -   `500 Internal Server Error`, `503 Service Unavailable`: Временная проблема на сервере. **Это главный кандидат на ретрай.**

**Стратегия ретраев:** Лучше всего использовать **экспоненциальную задержку (exponential backoff)** — повторять запрос через 1с, потом 2с, потом 4с и т.д. Это позволяет не "завалить" запросами сервер, который и так испытывает проблемы. Такую логику удобно реализовывать в `OkHttp Interceptor`.
