# Демонстрация знаний по алгоритмам и структурам данных

Этот документ объясняет основы сложности алгоритмов (Big-O), принципы выбора структур данных и решает практическую мини-задачу.

### 1. Big-O нотация (Сложность алгоритмов)

**Big-O** — это язык, который используется для описания производительности (сложности) алгоритма. Он показывает, как время выполнения алгоритма или требуемая память растут с увеличением объема входных данных.

-   **O(1) — Константная сложность**: Время выполнения не зависит от размера данных. (Пример: получение элемента из `HashMap` по ключу).
-   **O(log n) — Логарифмическая сложность**: Время выполнения растет очень медленно. (Пример: поиск в отсортированном массиве).
-   **O(n) — Линейная сложность**: Время выполнения растет прямо пропорционально данным. (Пример: перебор всех элементов в списке).
-   **O(n²)— Квадратичная сложность**: Время выполнения растет очень быстро. (Пример: вложенные циклы по одной и той же коллекции). Следует избегать по возможности.

### 2. Выбор структур данных

Правильный выбор структуры данных — ключ к эффективности. Вот три основные коллекции:

-   **`List` (ArrayList, LinkedList)**
    -   **Что это:** Упорядоченная коллекция, элементы доступны по индексу.
    -   **Когда использовать:** Когда важен порядок элементов или нужен доступ по индексу. `ArrayList` быстр для чтения, но медленнее для вставки/удаления в середину. `LinkedList` — наоборот.
    -   **Сложность (для ArrayList):** `get(index)` - O(1), `add(element)` - O(1) в среднем, `contains(element)` - O(n).

-   **`Set` (HashSet, TreeSet)**
    -   **Что это:** Коллекция, которая хранит только **уникальные** элементы.
    -   **Когда использовать:** Когда нужно убедиться в отсутствии дубликатов. `HashSet` очень быстр для проверки наличия элемента.
    -   **Сложность (для HashSet):** `add(element)` - O(1), `contains(element)` - O(1).

-   **`Map` (HashMap, TreeMap)**
    -   **Что это:** Коллекция пар "ключ-значение".
    -   **Когда использовать:** Когда нужен быстрый доступ к объекту по уникальному идентификатору (ключу).
    -   **Сложность (для HashMap):** `get(key)` - O(1), `put(key, value)` - O(1).

### 3. Мини-задача (Поиск, сортировка, преобразование)

**Задача:** Дан список объектов `Organization`. Нужно посчитать, сколько организаций в каждой стране, и вернуть результат в виде `Map<String, Int>`, отсортированной по названию страны.

**Решение на Kotlin:**

```kotlin
import app.test.networkapp.data.models.Organization

fun countAndSortOrganizationsByCountry(organizations: List<Organization>): Map<String, Int> {
    return organizations
        // Шаг 1: Отфильтровываем организации без указания страны
        .filter { !it.country.isNullOrBlank() }
        // Шаг 2: Группируем организации по стране. Результат: Map<String, List<Organization>>
        .groupBy { it.country!! }
        // Шаг 3: Преобразуем значения. Вместо списка организаций нам нужно их количество.
        // Результат: Map<String, Int>
        .mapValues { (_, orgsInCountry) -> orgsInCountry.size }
        // Шаг 4: Сортируем по ключу (названию страны)
        .toSortedMap()
}
```

#### Анализ сложности этого решения

Пройдемся по шагам:

1.  `filter`: Проходит по каждому элементу списка один раз. Сложность — **O(n)**.
2.  `groupBy`: Также проходит по каждому из `n` элементов, чтобы определить ключ и добавить в соответствующий список. Сложность — **O(n)**.
3.  `mapValues`: Проходит по каждому ключу в созданной `Map`. В худшем случае у нас `n` стран, но в сумме это будет `m` операций, где `m` — количество уникальных стран (`m <= n`).
4.  `toSortedMap`: Создает новую `TreeMap` из существующей `Map`. Это требует **O(m log m)** операций, где `m` — количество стран.

**Итоговая сложность:** Доминирующими операциями являются `filter` и `groupBy` (O(n)), а также сортировка (O(m log m)). Общая сложность алгоритма будет **O(n + m log m)**. Так как `m` не может быть больше `n`, в худшем случае сложность можно оценить как **O(n log n)**, что является очень эффективным результатом для такой задачи.
